{"meta":{"title":"timfish's Blog","subtitle":"春风秋月,杨柳依依","description":"灾难始终慢我一步","author":"timfish","url":"http://yoursite.com","root":"/"},"pages":[{"title":"","date":"2019-07-05T09:02:16.342Z","updated":"2019-07-05T09:02:16.342Z","comments":true,"path":"404.html","permalink":"http://yoursite.com/404.html","excerpt":"","text":"404 - arao'blog"},{"title":"博客分类","date":"2019-07-05T07:09:03.000Z","updated":"2019-07-09T09:27:29.073Z","comments":false,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"archives","date":"2019-07-05T08:14:49.000Z","updated":"2019-07-05T08:15:10.917Z","comments":true,"path":"archives/index.html","permalink":"http://yoursite.com/archives/index.html","excerpt":"","text":""},{"title":"blockchain","date":"2019-07-10T01:34:53.000Z","updated":"2019-07-10T01:44:26.783Z","comments":false,"path":"blockchain/index.html","permalink":"http://yoursite.com/blockchain/index.html","excerpt":"","text":"区块链导航栏,类似浩123 比特币 以太坊 柚子"},{"title":"博主简介","date":"2019-07-05T07:08:16.000Z","updated":"2019-07-09T09:25:15.861Z","comments":false,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"【昵称】: timfish 【坐标】: 北京,老家江西上饶 【职业】: 区块链开发,关键字:程序员 【兴趣和爱好】: 跑步，游戏，写作 【其他】: 暂无"},{"title":"博客标签","date":"2019-07-05T07:08:53.000Z","updated":"2019-07-09T09:27:11.917Z","comments":false,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Mysql知识点总结笔记","slug":"Mysql知识点总结笔记","date":"2019-07-26T03:26:52.000Z","updated":"2019-07-29T05:54:48.646Z","comments":false,"path":"2019/07/26/Mysql知识点总结笔记/","link":"","permalink":"http://yoursite.com/2019/07/26/Mysql知识点总结笔记/","excerpt":"知识列表 mysql的隔离级别有哪几种 什么是脏读、不可重复读、幻读 MVCC的实现原理 如何保证没有幻读发生的 聚簇索引和非聚簇索引的区别 MyISAM和InnoDB引擎的区别及各自的优缺点 常见的sql优化都有哪些点可以参考 如何进行大表的分页查询优化 一条查询sql的执行过程","text":"知识列表 mysql的隔离级别有哪几种 什么是脏读、不可重复读、幻读 MVCC的实现原理 如何保证没有幻读发生的 聚簇索引和非聚簇索引的区别 MyISAM和InnoDB引擎的区别及各自的优缺点 常见的sql优化都有哪些点可以参考 如何进行大表的分页查询优化 一条查询sql的执行过程 mysql的隔离级别有哪几种?分别有什么优缺点 123456789101112mysql共有四种事务隔离级别，分别是未提交读(READ UNCOMMITTED)、已提交读(READ COMMITTED)、可重复读(REPEATABLE READ)、可串行化(SERIALIZABLE),mysql的默认事务隔离级别是可重复读。未提交读: 一个事务中做的内容修改,即使没有进行事务提交,对其他事务也是可见的。这个级别会造成脏读，不可重复读,幻读。已提交读: 一个事务开始时，只能&quot;看到&quot;在事务开始之前的已经提交的事务所做的修改。也就是说，在这个隔离级别下，一个事务从开始到结束之间所做的修改，对其他事务是不可见的。这个级别会造成不可重复读，幻读。可重复读: 可重复读，在已提交读的前提下，保证了同一个事务多次读取同样的记录结果是一致的。可串行化: 可串行化是最高的隔离级别,它通过强制事务串行执行，避免了脏读，不可重复读，幻读的发生。实现原理就是在读取的每一行数据上进行加锁，这也就意味着会导致大量的超时和锁竞争问题。 四种隔离级别的安全性是从低 --&gt; 高的，相反的是并发性从 高 --&gt; 低。 什么是脏读、不可重复读、幻读 123456脏读: 一个事务能够&quot;看到&quot;到其他未提交事务的所做的修改，即称为脏读。不可重复读: 一个事务读取了某条记录后，另一个事务对该记录进行了修改，则当第一个事务再次读取该条记录，将会发现两次读取的结果不一致，即称为不可重复读。幻读: 所谓幻读，是指一个事务在读取某个范围的数据时，另外一个事务又在该范围之间插入了新的记录(或删除了几条记录)，这将导致之前的事务再次读取该范围的记录时，会多出一些记录(或少了一些记录)。即称为幻读。 MVCC的实现原理 123456789101112131415161718MVCC，即多版本并发控制,是行级锁的一个变种。简单来说,MVCC的实现是通过保存数据在某个时间点的快照来实现的，也就是不管一个事务执行多长的时间，每个事务看到的数据是一致的。根据每个事务开始的时间不同，每个事务对同一张表，同一个时刻看到的数据是不一样的。InnoDB的MVCC实现，是通过在每个行记录增加两个隐藏的列来实现的，这两个列，一个保存了该行的创建时间，一个保存了该行的过期时间(即删除时间)，存储的值是事务Id而不是时间，事务Id在InnoDB里是全局自增的，每当开始一个新的事务，事务Id都会加1。当 InnoDB 执行 SELECT 时: a. InnoDB 只会查询版本号&lt;= 当前事务Id的数据行,这样可以确保事务读取的行，要么是事务开始之前就已经存在的，要么是事务本身进行的插入或修改。 b. 行的删除版本号要么是未定义,要么是大于当前事务Id，这可以确保事务读取的行，在事务开始之前是未被删除的。 只有满足上述两个条件，才能作为查询结果进行返回。当 InnoDB 执行 INSERT 时: InnoDB为新插入的每一行保存当前事务Id作为行的版本号。当 InnoDB 执行 UPDATE 时: InnoDB会插入一条新的记录,并保证当前事务Id作为行的版本号,同时在原来行的过期列保存当前事务Id当作版本号，作为删除标识。当 InnoDB 执行 DELETE 时: InnoDB为删除的每一行保存当前事务Id作为行的删除标识。 注: InnoDB的MVCC只在已提交读，不可重复读两个隔离级别下工作。 如何保证没有幻读发生的 12345在当前读的前提下(当前读是指加锁的 select,update,delete语句),可以通过next-key locks 算法来消除幻读的发生。 即锁住索引记录之间的范围,避免范围内插入记录,从而防止幻影行记录。 在普通读的前提下,可以通过MVCC来解决幻读。 因为MVCC的读取需要同时满足行创建版本号&lt;=当前事务Id，同时行过期版本号不存在或大于当前事务Id。这样的话即使其他事务在同样的范围内有新的记录插入,也不会被该事务查询到。 聚簇索引和非聚簇索引的区别 123456聚簇索引即主键索引,索引树的叶子节点保存了完整的数据行。非聚簇索引则是指除了主键索引外的其他索引，即普通索引和唯一索引，索引树的叶子节点保存的是主键索引的值。所以一般而言，主键索引最好是自增并且是整数型的，这既可以减少非聚簇索引树的存储数据量，又防止了分页的发生。查询效率最高的当然是聚簇索引，因为普通索引查询的话一般会涉及到回表，即两次索引树的查询，而聚簇索引只需要一次索引树查询。除非所有查询的字段都在普通索引树上，这种查询效率也很好,也称为覆盖索引,在explain中表现为Extra字段中显示 Using index。 MyISAM和InnoDB引擎的区别及各自的优缺点 1234561. InnoDB支持事务,MyISAM不支持事务2. InnoDB数据存储在共享表空间,MyISAM数据存储在文件中3. InnoDB支持行级锁,MyISAM只支持表锁4. InnoDB支持崩溃后恢复,MyISAM不支持5. InnoDB支持外键,MyISAM不支持6. InnoDB不支持全文索引, MyISAM支持 常见的sql优化都有哪些点可以参考 12341.能走主键索引的尽量走主键索引2.能走覆盖索引的走覆盖索引3.复杂SQL最好优化成多个小SQL,这样查询缓存能充分利用4.可以通过前缀索引来减少索引的大小,如email字段,可以用email(n)来做前缀索引,具体n是多少，可以用count(email(n)) / count(email)这个值来比较选择度大小,如果增大n，选择度不再提高,此时n为合适的值 如何进行大表的分页查询优化 12345678910111213141516171. 页面中限制分页的数量 如果一张表的数据量在上百万，但是查询的数据基本是最新的那些，那么就可以限制页面的翻页最多是100页，京东商品的分页目前就是这样实现的。 2. 优化大偏移量的性能 分页查询基本是OFFSET的问题，导致MySQL扫描大量不需要的行然后再抛弃。如果可以记录上次取数据的位置，就可以避免OFFSET。 在实现上就是只能点击上一页或者下一页,这样的话就能根据当前页的数据优化分页查询SQL。 如 SELECT * FROM rental ORDER BY rental_id DESC LIMIT 20; 假设查询返回的主键为16049到16030，那么下一页的查询就可以从16030这个点开始: SELECT * FROM rental WHERE rental_id &lt; 16030 ORDER BY rental_id DESC LIMIT 20; 3. 优化大表LIMIT查询SQL,使用索引覆盖扫描 如 SELECT * FROM user ORDER BY id DESC LIMIT 100000,10; 在 user表的数据库量达到百万之后(id为主键) 优化成: SELECT u.* FROM user u INNER JOIN (SELECT id from user ORDER BY id DESC LIMIT 100000,10) AS uer USING(id); 性能能提升3倍左右4. 表分区 如果大表查询的数据基本都是最新的,则可以在表分成几个区,如100万一个分区,那么查询的时候就可以只扫描一个分区的数据。具体的执行计划，扫描了几个分区可以用 EXPLAIN PARTITIONS 查看 一条查询sql的执行过程 123451. 客户端发送一条查询给服务器2. 服务器先检查查询缓存，如果命中率缓存，则立刻返回存储在缓存中的结果。否则进入下一阶段3. 服务器端对SQL进行解析,预处理,在优化器生成对应的执行计划4. mysql根据优化器生成的执行计划，调用存储引擎的API来执行查询5. 将结果返回给客户端","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"Mysql","slug":"Mysql","permalink":"http://yoursite.com/tags/Mysql/"}]},{"title":"链表高频面试题汇总","slug":"链表面试题","date":"2019-07-19T07:18:25.000Z","updated":"2019-07-19T07:33:07.752Z","comments":false,"path":"2019/07/19/链表面试题/","link":"","permalink":"http://yoursite.com/2019/07/19/链表面试题/","excerpt":"单链表反转 链表中环的检测 两个有序列表的合并 删除链表倒数第n个节点 求链表的中间节点","text":"单链表反转 链表中环的检测 两个有序列表的合并 删除链表倒数第n个节点 求链表的中间节点 单链表反转leetCode 206题目描述123反转一个单链表。输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL 解题答案1234567891011121314151617181920212223class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; public ListNode reverseList(ListNode head) &#123; if (head == null) &#123; return null; &#125; ListNode pre = null; while (head != null) &#123; ListNode temp = head.next; head.next = pre; pre = head; // 前指针后移 head = temp; // 当前指针后移 &#125; return pre; &#125;&#125; 链表中环的检测leetCode 141题目描述123给定一个链表，判断链表中是否有环。为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。 解题答案123456789101112131415161718192021222324252627class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; public boolean hasCycle(ListNode head) &#123; if (head == null || head.next == null) &#123; return false; &#125; ListNode fastPointer = head; ListNode slowPointer = head; while (fastPointer != null &amp;&amp; fastPointer.next != null) &#123; fastPointer = fastPointer.next.next; slowPointer = slowPointer.next; if (fastPointer == slowPointer) &#123; return true; &#125; &#125; return false; &#125;&#125; 两个有序列表的合并leetCode 21题目描述123将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4 解题答案12345678910111213141516171819202122232425262728293031323334353637383940class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode result = new ListNode(-1); ListNode head = result; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val &lt; l2.val) &#123; head.next = l1; l1 = l1.next; &#125; else &#123; head.next = l2; l2 = l2.next; &#125; head = head.next; &#125; if (l1 != null) &#123; head.next = l1; l1 = l1.next; head = head.next; &#125; if (l2 != null) &#123; head.next = l2; l2 = l2.next; head = head.next; &#125; return result.next; &#125; &#125; 删除链表倒数第n个节点leetCode 19题目描述123456给定一个链表，删除链表的倒数第 n 个节点，并且返回链表的头结点。给定一个链表: 1-&gt;2-&gt;3-&gt;4-&gt;5, 和 n = 2.当删除了倒数第二个节点后，链表变为 1-&gt;2-&gt;3-&gt;5.给定的 n 保证是有效的。 解题答案1234567891011121314151617181920212223242526272829class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; public ListNode removeNthFromEnd(ListNode head, int n) &#123; head = reverseList(head); int count = 0; ListNode cur = new ListNode(-1); ListNode pre = cur; while (head != null) &#123; count++; if (count == n) &#123; pre.next = head.next; break; &#125; pre.next = head; pre = pre.next; head = head.next; &#125; return reverseList(cur.next); &#125; &#125; 求链表的中间节点leetCode 876题目描述12345678910给定一个带有头结点 head 的非空单链表，返回链表的中间结点。如果有两个中间结点，则返回第二个中间结点。示例1:输入:[1,2,3,4,5]输出:[3,4,5]示例2:输入:[1,2,3,4,5,6]输出:[4,5,6] 解题答案123456789101112131415161718192021222324252627class ListNode &#123; int val; ListNode next; ListNode(int x) &#123; val = x; &#125; public ListNode middleNode(ListNode head) &#123; int len = 0; ListNode cur = head; while (cur != null) &#123; len++; cur = cur.next; &#125; int step = len / 2; cur = head; while (step &gt; 0) &#123; step -= 1; cur = cur.next; &#125; return cur; &#125;&#125;","categories":[{"name":"面试","slug":"面试","permalink":"http://yoursite.com/categories/面试/"}],"tags":[{"name":"算法","slug":"算法","permalink":"http://yoursite.com/tags/算法/"},{"name":"面试","slug":"面试","permalink":"http://yoursite.com/tags/面试/"}]},{"title":"私人菜谱","slug":"私人菜谱","date":"2019-07-15T02:00:01.000Z","updated":"2019-07-15T02:07:26.173Z","comments":false,"path":"2019/07/15/私人菜谱/","link":"","permalink":"http://yoursite.com/2019/07/15/私人菜谱/","excerpt":"[toc] 可乐鸡翅食材","text":"[toc] 可乐鸡翅食材 鸡翅10只,含糖可乐一罐,小葱10g,姜片20g,生抽15ml，老抽15ml,料酒15ml,桂皮10g,盐适量 步骤 鸡翅用水冲洗干净，并在鸡翅的每一面划上3刀 将鸡翅放入锅中,加清水,加姜片10g，葱段10g，下锅煮开,捞出鸡翅并洗净浮末，沥干水分待用 洗锅后下底油,6层油热，将10g姜片下锅,然后将鸡翅一只只入锅,两面煎成微黄色 将可乐倒入锅中,浸没鸡翅为止，然后加生抽15ml，老抽15ml,料酒15ml,桂皮，盐 盖上锅盖开大火烧开后转小火，待汤汁粘稠关火装盘，撒上葱花即可糖醋排骨食材排骨500g,蒜头6瓣，姜片15g,生抽15ml(一勺),老抽15ml,料酒15ml,醋3勺，白砂糖4勺,盐适量步骤 排骨切成小段,洗干净后用清水浸泡10分钟左右,并用盐腌制 锅里下油,6成热后，放入切好的姜片和蒜头,爆香 将腌制好的排骨倒入锅中,大火煎成两面肉变成熟色 加入1勺生抽,1勺老抽,1勺料酒,3勺醋,4勺白砂糖,加入少许盐后搅拌均匀,倒入大半碗清水 盖上锅盖，转至中火开始煮,中途再翻炒几下,大约20分钟煮至收汁(注意盯住火候,不要煮焦),均匀翻弄几下,装盘即可冬瓜瘦肉汤食材冬瓜一斤,瘦肉150g,小葱10g,姜片10g,盐适量步骤 廋肉切成片,生抽一🥄,料酒一🥄,一🥄盐,淀粉腌制10分钟 冬瓜去皮,切成薄片,姜切丝，葱切断备用 热锅少量油,6成油熟放姜丝,翻炒几下,放冬瓜片,大火炒3分钟 倒入汤碗的8/10左右的清水,放入2🥄盐,盖上锅盖大火熟5分钟,中火10分钟 撒上葱花,关火上菜芹菜炒肉食材小芹菜一把,廋肉300g,红辣椒2个(不辣那种),生抽15ml,蒜4瓣盐,料酒步骤 廋肉切成片,生抽一🥄,料酒一🥄,一🥄盐,淀粉腌制10分钟 芹菜洗净,去头去尾,切成段,装盘待用, 锅内少许油,6成热后，放入肉片，炒至变色 加入蒜瓣炒出香后，倒入切好的芹菜，大火翻炒30秒 加入一勺生抽，大火继续翻炒30秒 出锅前放入适量盐即可","categories":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/categories/生活/"}],"tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]},{"title":"mac下docker安装各种数据库","slug":"mac下docker安装各种数据库","date":"2019-07-11T09:08:04.000Z","updated":"2019-07-11T09:10:48.730Z","comments":false,"path":"2019/07/11/mac下docker安装各种数据库/","link":"","permalink":"http://yoursite.com/2019/07/11/mac下docker安装各种数据库/","excerpt":"","text":"mysql 首先利用docker search mysql 查看相关镜像库 mongodbredis","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"docker","slug":"docker","permalink":"http://yoursite.com/tags/docker/"},{"name":"mysql","slug":"mysql","permalink":"http://yoursite.com/tags/mysql/"},{"name":"redis","slug":"redis","permalink":"http://yoursite.com/tags/redis/"},{"name":"mongodb","slug":"mongodb","permalink":"http://yoursite.com/tags/mongodb/"}]},{"title":"2019我的读书清单","slug":"2019我的读书清单","date":"2019-07-10T09:14:15.000Z","updated":"2019-08-07T01:56:55.985Z","comments":false,"path":"2019/07/10/2019我的读书清单/","link":"","permalink":"http://yoursite.com/2019/07/10/2019我的读书清单/","excerpt":"2019匆匆过半，回望这半年，虽然也有虚度，但还算上进。下半年继续砥砺前行~ 四月(9)技术(5) &lt;&lt;亿级流量网站架构核心技术&gt;&gt;(2019-03-30 ~ 2019-04-02) &lt;&lt;rabbitmq实战指南&gt;&gt;(2019-04-03 ~ 2019-04-09) &lt;&lt;java并发编程实战&gt;&gt;(2019-03-27 ~ 2019-04-13) &lt;&lt;分布式服务架构&gt;&gt;(2019-04-18 ~ 2019-04-29) &lt;&lt;redis设计与实现&gt;&gt;(2019-04-04 ~ 2019-04-17)","text":"2019匆匆过半，回望这半年，虽然也有虚度，但还算上进。下半年继续砥砺前行~ 四月(9)技术(5) &lt;&lt;亿级流量网站架构核心技术&gt;&gt;(2019-03-30 ~ 2019-04-02) &lt;&lt;rabbitmq实战指南&gt;&gt;(2019-04-03 ~ 2019-04-09) &lt;&lt;java并发编程实战&gt;&gt;(2019-03-27 ~ 2019-04-13) &lt;&lt;分布式服务架构&gt;&gt;(2019-04-18 ~ 2019-04-29) &lt;&lt;redis设计与实现&gt;&gt;(2019-04-04 ~ 2019-04-17) 其他(4) &lt;&lt;钱:7步创造终身收入&gt;&gt;(2019-01-21 ~ 2019-04-07) &lt;&lt;人设&gt;&gt;(2019-04-21 ~ 2019-04-24) &lt;&lt;漫步华尔街&gt;&gt;(2019-04-11 ~ 2019-04-23) &lt;&lt;Learn more study less,如何高效学习&gt;&gt;(2019-04-21 ~ 2019-04-22) 五月(6)技术(4) &lt;&lt;高性能mysql第2版&gt;&gt;(2019-04-27 ~ 2019-05-06) &lt;&lt;码出高效&gt;&gt;(2019-04-23 ~ 2019-05-07) &lt;&lt;区块链密码共识原理、产业与应用&gt;&gt;(2019-04-29 ~ 2019-05-16) &lt;&lt;大型网站系统与java中间件实践&gt;&gt;(2019-05-07 ~ 2019-05-09) 其他(2) &lt;&lt;羊皮书&gt;&gt;(2019-04-22 ~ 2019-05-04) &lt;&lt;你的孤独,虽败犹荣&gt;&gt;(2019-04-03 ~ 2019-05-14) 六月(2)技术(1) &lt;&lt;精通比特币&gt;&gt;(2019-06-10 ~ 2019-06-17) 其他(1) &lt;&lt;以交易为生(第2版)&gt;&gt;(2019-05-12 ~ 2019-06-23) 七月(6)技术(3) &lt;&lt;深入理解java内存模型&gt;&gt;(2019-06-19 ~ 2019-07-04) &lt;&lt;图解TCP/IP&gt;&gt;(2019-06-24 ~ 2019-07-10) &lt;&lt;head first设计模式&gt;&gt;(2019-05-19 ~ 2019-07-28) 其他(1) &lt;&lt;深度思维:透过复杂直抵本质&gt;&gt;(2019-07-08 ~ 2019-07-15) 极客时间专栏(2) &lt;&lt;java并发编程实战&gt;&gt;(2019-05-27 ~ 2019-07-03) &lt;&lt;程序员进阶攻略61讲&gt;&gt;(2019-07-04 ~ 2019-07-29) ###八月(2) 技术(1) &lt;&lt;图解http&gt;&gt;(2019-07-25 ~ 2019-08-01) 其他(1) &lt;&lt;一万小时天才理论&gt;&gt;(2019-07-15 ~ 2019-08-02) 极客时间专栏(0)","categories":[{"name":"清单","slug":"清单","permalink":"http://yoursite.com/categories/清单/"}],"tags":[{"name":"读书","slug":"读书","permalink":"http://yoursite.com/tags/读书/"}]},{"title":"zk分布式锁实现原理","slug":"zk分布式锁实现原理","date":"2019-07-08T09:38:00.000Z","updated":"2019-07-09T09:32:19.723Z","comments":false,"path":"2019/07/08/zk分布式锁实现原理/","link":"","permalink":"http://yoursite.com/2019/07/08/zk分布式锁实现原理/","excerpt":"zk分布式锁实现原理流程图如下:","text":"zk分布式锁实现原理流程图如下:","categories":[{"name":"分布式","slug":"分布式","permalink":"http://yoursite.com/categories/分布式/"}],"tags":[{"name":"zookeeper","slug":"zookeeper","permalink":"http://yoursite.com/tags/zookeeper/"},{"name":"分布式锁","slug":"分布式锁","permalink":"http://yoursite.com/tags/分布式锁/"}]},{"title":"hexo开源博客搭建教程","slug":"hexo搭建教程","date":"2019-07-05T07:45:51.000Z","updated":"2019-07-09T06:57:18.920Z","comments":false,"path":"2019/07/05/hexo搭建教程/","link":"","permalink":"http://yoursite.com/2019/07/05/hexo搭建教程/","excerpt":"开源博客搭建过程","text":"开源博客搭建过程 npm安装12345671. cd /usr/local/node 没有则创建2. wget https://npm.taobao.org/mirrors/node/v10.16.0/node-v10.16.0-linux-x64.tar.gz3. tar -zxvf node-v10.16.0-linux-x64.tar.gz4. rm -rf node-v10.16.0-linux-x64.tar.gz5. ln -s /usr/local/node/node-v10.16.0-linux-x64/bin/npm /usr/local/bin/npm6. ln -s /usr/local/node/node-v10.16.0-linux-x64/bin/node /usr/local/bin/node7. npm -v 正常显示版本号就ok","categories":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/categories/教程/"}],"tags":[{"name":"教程","slug":"教程","permalink":"http://yoursite.com/tags/教程/"}]}]}